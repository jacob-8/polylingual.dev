// Vitest Snapshot v1

exports[`process_docs > parses docs into section by file 1`] = `
[
  {
    "filename": "/10-getting-started/10-introduction.md",
    "sections": [
      {
        "children": [
          {
            "content": "> If you're new to Svelte or SvelteKit we recommend checking out the (experimental!) [interactive tutorial](https://learn.svelte.dev). > > If you get stuck, reach out for help in the [Discord chatroom](https://svelte.dev/chat). ",
            "title": "Before we begin",
          },
          {
            "content": "SvelteKit is a framework for rapidly developing robust, performant web applications using [Svelte](https://svelte.dev/). If you're coming from React, SvelteKit is similar to Next. If you're coming from Vue, SvelteKit is similar to Nuxt. ",
            "title": "What is SvelteKit?",
          },
          {
            "content": "In short, Svelte is a way of writing user interface components — like a navigation bar, comment section, or contact form — that users see and interact with in their browsers. The Svelte compiler converts your components to JavaScript that can be run to render the HTML for the page and to CSS that styles the page. You don't need to know Svelte to understand the rest of this guide, but it will help. If you'd like to learn more, check out [the Svelte tutorial](https://svelte.dev/tutorial). ",
            "title": "What is Svelte?",
          },
          {
            "content": "Svelte renders UI components. You can compose these components and render an entire page with just Svelte, but you need more than just Svelte to write an entire app. SvelteKit provides basic functionality like a [router](glossary#routing) — which updates the UI when a link is clicked — and [server-side rendering (SSR)](glossary#ssr). But beyond that, building an app with all the modern best practices is fiendishly complicated. Those practices include [build optimizations](https://vitejs.dev/guide/features.html#build-optimizations), so that you load only the minimal required code; [offline support](service-workers); [preloading](link-options#data-sveltekit-preload-data) pages before the user initiates navigation; [configurable rendering](page-options) that allows you to render different parts of your app on the server with [SSR](glossary#ssr), in the browser [client-side rendering](glossary#csr), or at build-time with [prerendering](glossary#prerendering); and many other things. SvelteKit does all the boring stuff for you so that you can get on with the creative part. It reflects changes to your code in the browser instantly to provide a lightning-fast and feature-rich development experience by leveraging [Vite](https://vitejs.dev/) with a [Svelte plugin](https://github.com/sveltejs/vite-plugin-svelte) to do [Hot Module Replacement (HMR)](https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/config.md#hot). ",
            "title": "What does SvelteKit provide on top of Svelte?",
          },
        ],
        "content": "",
        "title": "Introduction",
      },
    ],
  },
  {
    "filename": "/10-getting-started/20-creating-a-project.md",
    "sections": [
      {
        "children": [
          {
            "content": "We recommend using [Visual Studio Code (aka VS Code)](https://code.visualstudio.com/download) with [the Svelte extension](https://marketplace.visualstudio.com/items?itemName=svelte.svelte-vscode), but [support also exists for numerous other editors](https://sveltesociety.dev/tools#editor-support). ",
            "title": "Editor setup",
          },
        ],
        "content": "The easiest way to start building a SvelteKit app is to run \`npm create\`: \`\`\`bash npm create svelte@latest my-app cd my-app npm install npm run dev \`\`\` The first command will scaffold a new project in the \`my-app\` directory asking you if you'd like to set up some basic tooling such as TypeScript. See the FAQ for [pointers on setting up additional tooling](/faq#integrations). The subsequent commands will then install its dependencies and start a server on [localhost:5173](http://localhost:5173). There are two basic concepts: *   Each page of your app is a [Svelte](https://svelte.dev) component *   You create pages by adding files to the \`src/routes\` directory of your project. These will be server-rendered so that a user's first visit to your app is as fast as possible, then a client-side app takes over Try editing the files to get a feel for how everything works. ",
        "title": "Creating a project",
      },
    ],
  },
  {
    "filename": "/20-core-concepts/10-routing.md",
    "sections": [
      {
        "children": [
          {
            "children": [
              {
                "content": "A \`+page.svelte\` component defines a page of your app. By default, pages are rendered both on the server ([SSR](glossary#ssr)) for the initial request and in the browser ([CSR](glossary#csr)) for subsequent navigation. \`\`\`svelte /// file: src/routes/+page.svelte <h1>Hello and welcome to my site!</h1> <a href=\\"/about\\">About my site</a> \`\`\` \`\`\`svelte /// file: src/routes/about/+page.svelte <h1>About this site</h1> <p>TODO...</p> <a href=\\"/\\">Home</a> \`\`\` \`\`\`svelte /// file: src/routes/blog/[slug]/+page.svelte <script> 	/** @type {import('./$types').PageData} */ 	export let data; </script>  <h1>{data.title}</h1> <div>{@html data.content}</div> \`\`\` > Note that SvelteKit uses \`<a>\` elements to navigate between routes, rather than a framework-specific \`<Link>\` component. ",
                "title": "+page.svelte",
              },
              {
                "content": "Often, a page will need to load some data before it can be rendered. For this, we add a \`+page.js\` (or \`+page.ts\`, if you're TypeScript-inclined) module that exports a \`load\` function: \`\`\`js /// file: src/routes/blog/[slug]/+page.js import { error } from '@sveltejs/kit';  /** @type {import('./$types').PageLoad} */ export function load({ params }) { 	if (params.slug === 'hello-world') { 		return { 			title: 'Hello world!', 			content: 'Welcome to our blog. Lorem ipsum dolor sit amet...' 		}; 	}  	throw error(404, 'Not found'); } \`\`\` This function runs alongside \`+page.svelte\`, which means it runs on the server during server-side rendering and in the browser during client-side navigation. See [\`load\`](load) for full details of the API. As well as \`load\`, \`+page.js\` can export values that configure the page's behaviour: *   \`export const prerender = true\` or \`false\` or \`'auto'\` *   \`export const ssr = true\` or \`false\` *   \`export const csr = true\` or \`false\` You can find more information about these in [page options](page-options). ",
                "title": "+page.js",
              },
              {
                "content": "If your \`load\` function can only run on the server — for example, if it needs to fetch data from a database or you need to access private [environment variables](modules#$env-static-private) like API keys — then you can rename \`+page.js\` to \`+page.server.js\` and change the \`PageLoad\` type to \`PageServerLoad\`. \`\`\`js /// file: src/routes/blog/[slug]/+page.server.js  // @filename: ambient.d.ts declare global { 	const getPostFromDatabase: (slug: string) => { 		title: string; 		content: string; 	} }  export {};  // @filename: index.js // ---cut--- import { error } from '@sveltejs/kit';  /** @type {import('./$types').PageServerLoad} */ export async function load({ params }) { 	const post = await getPostFromDatabase(params.slug);  	if (post) { 		return post; 	}  	throw error(404, 'Not found'); } \`\`\` During client-side navigation, SvelteKit will load this data from the server, which means that the returned value must be serializable using [devalue](https://github.com/rich-harris/devalue). See [\`load\`](load) for full details of the API. Like \`+page.js\`, \`+page.server.js\` can export [page options](page-options) — \`prerender\`, \`ssr\` and \`csr\`. A \`+page.server.js\` file can also export *actions*. If \`load\` lets you read data from the server, \`actions\` let you write data *to* the server using the \`<form>\` element. To learn how to use them, see the [form actions](form-actions) section. ",
                "title": "+page.server.js",
              },
            ],
            "content": "",
            "title": "+page",
          },
          {
            "content": "If an error occurs during \`load\`, SvelteKit will render a default error page. You can customise this error page on a per-route basis by adding an \`+error.svelte\` file: \`\`\`svelte /// file: src/routes/blog/[slug]/+error.svelte <script> 	import { page } from '$app/stores'; </script>  <h1>{$page.status}: {$page.error.message}</h1> \`\`\` SvelteKit will 'walk up the tree' looking for the closest error boundary — if the file above didn't exist it would try \`src/routes/blog/+error.svelte\` and then \`src/routes/+error.svelte\` before rendering the default error page. If *that* fails (or if the error was thrown from the \`load\` function of the root \`+layout\`, which sits 'above' the root \`+error\`), SvelteKit will bail out and render a static fallback error page, which you can customise by creating a \`src/error.html\` file. If the error occurs inside a \`load\` function in \`+layout(.server).js\`, the closest error boundary in the tree is an \`+error.svelte\` file *above* that layout (not next to it). If no route can be found (404), \`src/routes/+error.svelte\` (or the default error page, if that file does not exist) will be used. > \`+error.svelte\` is *not* used when an error occurs inside [\`handle\`](hooks#server-hooks-handle) or a [+server.js](#server) request handler. You can read more about error handling [here](errors). ",
            "title": "+error",
          },
          {
            "children": [
              {
                "content": "To create a layout that applies to every page, make a file called \`src/routes/+layout.svelte\`. The default layout (the one that SvelteKit uses if you don't bring your own) looks like this... \`\`\`html <slot></slot> \`\`\` ...but we can add whatever markup, styles and behaviour we want. The only requirement is that the component includes a \`<slot>\` for the page content. For example, let's add a nav bar: \`\`\`html /// file: src/routes/+layout.svelte <nav> 	<a href=\\"/\\">Home</a> 	<a href=\\"/about\\">About</a> 	<a href=\\"/settings\\">Settings</a> </nav>  <slot></slot> \`\`\` If we create pages for \`/\`, \`/about\` and \`/settings\`... \`\`\`html /// file: src/routes/+page.svelte <h1>Home</h1> \`\`\` \`\`\`html /// file: src/routes/about/+page.svelte <h1>About</h1> \`\`\` \`\`\`html /// file: src/routes/settings/+page.svelte <h1>Settings</h1> \`\`\` ...the nav will always be visible, and clicking between the three pages will only result in the \`<h1>\` being replaced. Layouts can be *nested*. Suppose we don't just have a single \`/settings\` page, but instead have nested pages like \`/settings/profile\` and \`/settings/notifications\` with a shared submenu (for a real-life example, see [github.com/settings](https://github.com/settings)). We can create a layout that only applies to pages below \`/settings\` (while inheriting the root layout with the top-level nav): \`\`\`svelte /// file: src/routes/settings/+layout.svelte <script> 	/** @type {import('./$types').LayoutData} */ 	export let data; </script>  <h1>Settings</h1>  <div class=\\"submenu\\"> 	{#each data.sections as section} 		<a href=\\"/settings/{section.slug}\\">{section.title}</a> 	{/each} </div>  <slot></slot> \`\`\` By default, each layout inherits the layout above it. Sometimes that isn't what you want - in this case, [advanced layouts](advanced-routing#advanced-layouts) can help you. ",
                "title": "+layout.svelte",
              },
              {
                "content": "Just like \`+page.svelte\` loading data from \`+page.js\`, your \`+layout.svelte\` component can get data from a [\`load\`](load) function in \`+layout.js\`. \`\`\`js /// file: src/routes/settings/+layout.js /** @type {import('./$types').LayoutLoad} */ export function load() { 	return { 		sections: [ 			{ slug: 'profile', title: 'Profile' }, 			{ slug: 'notifications', title: 'Notifications' } 		] 	}; } \`\`\` If a \`+layout.js\` exports [page options](page-options) — \`prerender\`, \`ssr\` and \`csr\` — they will be used as defaults for child pages. Data returned from a layout's \`load\` function is also available to all its child pages: \`\`\`svelte /// file: src/routes/settings/profile/+page.svelte <script> 	/** @type {import('./$types').PageData} */ 	export let data;  	console.log(data.sections); // [{ slug: 'profile', title: 'Profile' }, ...] </script> \`\`\` > Often, layout data is unchanged when navigating between pages. SvelteKit will intelligently re-run [\`load\`](load) functions when necessary. ",
                "title": "+layout.js",
              },
              {
                "content": "To run your layout's \`load\` function on the server, move it to \`+layout.server.js\`, and change the \`LayoutLoad\` type to \`LayoutServerLoad\`. Like \`+layout.js\`, \`+layout.server.js\` can export [page options](page-options) — \`prerender\`, \`ssr\` and \`csr\`. ",
                "title": "+layout.server.js",
              },
            ],
            "content": "So far, we've treated pages as entirely standalone components — upon navigation, the existing \`+page.svelte\` component will be destroyed, and a new one will take its place. But in many apps, there are elements that should be visible on *every* page, such as top-level navigation or a footer. Instead of repeating them in every \`+page.svelte\`, we can put them in *layouts*. ",
            "title": "+layout",
          },
          {
            "children": [
              {
                "content": "By exporting \`POST\`/\`PUT\`/\`PATCH\`/\`DELETE\`/\`OPTIONS\` handlers, \`+server.js\` files can be used to create a complete API: \`\`\`svelte /// file: src/routes/add/+page.svelte <script> 	let a = 0; 	let b = 0; 	let total = 0;  	async function add() { 		const response = await fetch('/api/add', { 			method: 'POST', 			body: JSON.stringify({ a, b }), 			headers: { 				'content-type': 'application/json' 			} 		});  		total = await response.json(); 	} </script>  <input type=\\"number\\" bind:value={a}> + <input type=\\"number\\" bind:value={b}> = {total}  <button on:click={add}>Calculate</button> \`\`\` \`\`\`js /// file: src/routes/api/add/+server.js import { json } from '@sveltejs/kit';  /** @type {import('./$types').RequestHandler} */ export async function POST({ request }) { 	const { a, b } = await request.json(); 	return json(a + b); } \`\`\` > In general, [form actions](form-actions) are a better way to submit data from the browser to the server. ",
                "title": "Receiving data",
              },
              {
                "content": "\`+server.js\` files can be placed in the same directory as \`+page\` files, allowing the same route to be either a page or an API endpoint. To determine which, SvelteKit applies the following rules: *   \`PUT\`/\`PATCH\`/\`DELETE\`/\`OPTIONS\` requests are always handled by \`+server.js\` since they do not apply to pages *   \`GET\`/\`POST\` requests are treated as page requests if the \`accept\` header prioritises \`text/html\` (in other words, it's a browser page request), else they are handled by \`+server.js\` ",
                "title": "Content negotiation",
              },
            ],
            "content": "As well as pages, you can define routes with a \`+server.js\` file (sometimes referred to as an 'API route' or an 'endpoint'), which gives you full control over the response. Your \`+server.js\` file (or \`+server.ts\`) exports functions corresponding to HTTP verbs like \`GET\`, \`POST\`, \`PATCH\`, \`PUT\`, \`DELETE\`, and \`OPTIONS\` that take a \`RequestEvent\` argument and return a [\`Response\`](https://developer.mozilla.org/en-US/docs/Web/API/Response) object. For example we could create an \`/api/random-number\` route with a \`GET\` handler: \`\`\`js /// file: src/routes/api/random-number/+server.js import { error } from '@sveltejs/kit';  /** @type {import('./$types').RequestHandler} */ export function GET({ url }) { 	const min = Number(url.searchParams.get('min') ?? '0'); 	const max = Number(url.searchParams.get('max') ?? '1');  	const d = max - min;  	if (isNaN(d) || d < 0) { 		throw error(400, 'min and max must be numbers, and min must be less than max'); 	}  	const random = min + Math.random() * d;  	return new Response(String(random)); } \`\`\` The first argument to \`Response\` can be a [\`ReadableStream\`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream), making it possible to stream large amounts of data or create server-sent events (unless deploying to platforms that buffer responses, like AWS Lambda). You can use the [\`error\`](modules#sveltejs-kit-error), [\`redirect\`](modules#sveltejs-kit-redirect) and [\`json\`](modules#sveltejs-kit-json) methods from \`@sveltejs/kit\` for convenience (but you don't have to). If an error is thrown (either \`throw error(...)\` or an unexpected error), the response will be a JSON representation of the error or a fallback error page — which can be customised via \`src/error.html\` — depending on the \`Accept\` header. The [\`+error.svelte\`](#error) component will *not* be rendered in this case. You can read more about error handling [here](errors). > When creating an \`OPTIONS\` handler, note that Vite will inject \`Access-Control-Allow-Origin\` and \`Access-Control-Allow-Methods\` headers — these will not be present in production unless you add them. ",
            "title": "+server",
          },
          {
            "content": "Throughout the examples above, we've been importing types from a \`$types.d.ts\` file. This is a file SvelteKit creates for you in a hidden directory if you're using TypeScript (or JavaScript with JSDoc type annotations) to give you type safety when working with your root files. For example, annotating \`export let data\` with \`PageData\` (or \`LayoutData\`, for a \`+layout.svelte\` file) tells TypeScript that the type of \`data\` is whatever was returned from \`load\`: \`\`\`svelte /// file: src/routes/blog/[slug]/+page.svelte <script> 	/** @type {import('./$types').PageData} */ 	export let data; </script> \`\`\` In turn, annotating the \`load\` function with \`PageLoad\`, \`PageServerLoad\`, \`LayoutLoad\` or \`LayoutServerLoad\` (for \`+page.js\`, \`+page.server.js\`, \`+layout.js\` and \`+layout.server.js\` respectively) ensures that \`params\` and the return value are correctly typed. ",
            "title": "$types",
          },
          {
            "content": "Any other files inside a route directory are ignored by SvelteKit. This means you can colocate components and utility modules with the routes that need them. If components and modules are needed by multiple routes, it's a good idea to put them in [\`$lib\`](modules#$lib). ",
            "title": "Other files",
          },
        ],
        "content": "At the heart of SvelteKit is a *filesystem-based router*. The routes of your app — i.e. the URL paths that users can access — are defined by the directories in your codebase: *   \`src/routes\` is the root route *   \`src/routes/about\` creates an \`/about\` route *   \`src/routes/blog/[slug]\` creates a route with a *parameter*, \`slug\`, that can be used to load data dynamically when a user requests a page like \`/blog/hello-world\` > You can change \`src/routes\` to a different directory by editing the [project config](configuration). Each route directory contains one or more *route files*, which can be identified by their \`+\` prefix. ",
        "title": "Routing",
      },
    ],
  },
  {
    "filename": "/20-core-concepts/20-load.md",
    "sections": [
      {
        "children": [
          {
            "content": "A \`+page.svelte\` file can have a sibling \`+page.js\` (or \`+page.ts\`) that exports a \`load\` function, the return value of which is available to the page via the \`data\` prop: \`\`\`js /// file: src/routes/blog/[slug]/+page.js /** @type {import('./$types').PageLoad} */ export function load({ params }) { 	return { 		post: { 			title: \`Title for \${params.slug} goes here\`, 			content: \`Content for \${params.slug} goes here\` 		} 	}; } \`\`\` \`\`\`svelte /// file: src/routes/blog/[slug]/+page.svelte <script> 	/** @type {import('./$types').PageData} */ 	export let data; </script>  <h1>{data.post.title}</h1> <div>{@html data.post.content}</div> \`\`\` Thanks to the generated \`$types\` module, we get full type safety. A \`load\` function in a \`+page.js\` file runs both on the server and in the browser. If your \`load\` function should *always* run on the server (because it uses private environment variables, for example, or accesses a database) then it would go in a \`+page.server.js\` instead. A more realistic version of your blog post's \`load\` function, that only runs on the server and pulls data from a database, might look like this: \`\`\`js /// file: src/routes/blog/[slug]/+page.server.js // @filename: ambient.d.ts declare module '$lib/server/database' { 	export function getPost(slug: string): Promise<{ title: string, content: string }> }  // @filename: index.js // ---cut--- import * as db from '$lib/server/database';  /** @type {import('./$types').PageServerLoad} */ export async function load({ params }) { 	return { 		post: await db.getPost(params.slug) 	}; } \`\`\` Notice that the type changed from \`PageLoad\` to \`PageServerLoad\`, because server \`load\` functions can access additional arguments. To understand when to use \`+page.js\` and when to use \`+page.server.js\`, see [Universal vs server](load#universal-vs-server). ",
            "title": "Page data",
          },
          {
            "content": "Your \`+layout.svelte\` files can also load data, via \`+layout.js\` or \`+layout.server.js\`. \`\`\`js /// file: src/routes/blog/[slug]/+layout.server.js // @filename: ambient.d.ts declare module '$lib/server/database' { 	export function getPostSummaries(): Promise<Array<{ title: string, slug: string }>> }  // @filename: index.js // ---cut--- import * as db from '$lib/server/database';  /** @type {import('./$types').LayoutServerLoad} */ export async function load() { 	return { 		posts: await db.getPostSummaries() 	}; } \`\`\` \`\`\`svelte /// file: src/routes/blog/[slug]/+layout.svelte <script> 	/** @type {import('./$types').LayoutData} */ 	export let data; </script>  <main> 	<!-- +page.svelte is rendered in this <slot> --> 	<slot /> </main>  <aside> 	<h2>More posts</h2> 	<ul> 		{#each data.posts as post} 			<li> 				<a href=\\"/blog/{post.slug}\\"> 					{post.title} 				</a> 			</li> 		{/each} 	</ul> </aside> \`\`\` Data returned from layout \`load\` functions is available to child \`+layout.svelte\` components and the \`+page.svelte\` component as well as the layout that it 'belongs' to. \`\`\`diff /// file: src/routes/blog/[slug]/+page.svelte <script> +	import { page } from '$app/stores';  	/** @type {import('./$types').PageData} */ 	export let data;  +	// we can access \`data.posts\` because it's returned from +	// the parent layout \`load\` function +	$: index = data.posts.findIndex(post => post.slug === $page.params.slug); +	$: next = data.posts[index - 1]; </script>  <h1>{data.post.title}</h1> <div>{@html data.post.content}</div>  +{#if next} +	<p>Next post: <a href=\\"/blog/{next.slug}\\">{next.title}</a></p> +{/if} \`\`\` > If multiple \`load\` functions return data with the same key, the last one 'wins' — the result of a layout \`load\` returning \`{ a: 1, b: 2 }\` and a page \`load\` returning \`{ b: 3, c: 4 }\` would be \`{ a: 1, b: 3, c: 4 }\`. ",
            "title": "Layout data",
          },
          {
            "content": "The \`+page.svelte\` component, and each \`+layout.svelte\` component above it, has access to its own data plus all the data from its parents. In some cases, we might need the opposite — a parent layout might need to access page data or data from a child layout. For example, the root layout might want to access a \`title\` property returned from a \`load\` function in \`+page.js\` or \`+page.server.js\`. This can be done with \`$page.data\`: \`\`\`svelte /// file: src/routes/+layout.svelte <script> 	import { page } from '$app/stores'; </script>  <svelte:head> 	<title>{$page.data.title}</title> </svelte:head> \`\`\` Type information for \`$page.data\` is provided by \`App.PageData\`. ",
            "title": "$page.data",
          },
          {
            "children": [
              {
                "content": "Both universal and server \`load\` functions have access to properties describing the request (\`params\`, \`route\` and \`url\`) and various functions (\`fetch\`, \`setHeaders\`, \`parent\` and \`depends\`). These are described in the following sections. Server \`load\` functions are called with a \`ServerLoadEvent\`, which inherits \`clientAddress\`, \`cookies\`, \`locals\`, \`platform\` and \`request\` from \`RequestEvent\`. Universal \`load\` functions are called with a \`LoadEvent\`, which has a \`data\` property. If you have \`load\` functions in both \`+page.js\` and \`+page.server.js\` (or \`+layout.js\` and \`+layout.server.js\`), the return value of the server \`load\` function is the \`data\` property of the universal \`load\` function's argument. ",
                "title": "Input",
              },
              {
                "content": "A universal \`load\` function can return an object containing any values, including things like custom classes and component constructors. A server \`load\` function must return data that can be serialized with [devalue](https://github.com/rich-harris/devalue) — anything that can be represented as JSON plus things like \`BigInt\`, \`Date\`, \`Map\`, \`Set\` and \`RegExp\`, or repeated/cyclical references — so that it can be transported over the network. Your data can include [promises](#streaming-with-promises), in which case it will be streamed to browsers. ",
                "title": "Output",
              },
              {
                "content": "Server \`load\` functions are convenient when you need to access data directly from a database or filesystem, or need to use private environment variables. Universal \`load\` functions are useful when you need to \`fetch\` data from an external API and don't need private credentials, since SvelteKit can get the data directly from the API rather than going via your server. They are also useful when you need to return something that can't be serialized, such as a Svelte component constructor. In rare cases, you might need to use both together — for example, you might need to return an instance of a custom class that was initialised with data from your server. ",
                "title": "When to use which",
              },
            ],
            "content": "As we've seen, there are two types of \`load\` function: *   \`+page.js\` and \`+layout.js\` files export *universal* \`load\` functions that run both on the server and in the browser *   \`+page.server.js\` and \`+layout.server.js\` files export *server* \`load\` functions that only run server-side Conceptually, they're the same thing, but there are some important differences to be aware of. ",
            "title": "Universal vs server",
          },
          {
            "children": [
              {
                "content": "An instance of [\`URL\`](https://developer.mozilla.org/en-US/docs/Web/API/URL), containing properties like the \`origin\`, \`hostname\`, \`pathname\` and \`searchParams\` (which contains the parsed query string as a [\`URLSearchParams\`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) object). \`url.hash\` cannot be accessed during \`load\`, since it is unavailable on the server. > In some environments this is derived from request headers during server-side rendering. If you're using [adapter-node](adapter-node), for example, you may need to configure the adapter in order for the URL to be correct. ",
                "title": "url",
              },
              {
                "content": "Contains the name of the current route directory, relative to \`src/routes\`: \`\`\`js /// file: src/routes/a/[b]/[...c]/+page.js /** @type {import('./$types').PageLoad} */ export function load({ route }) { 	console.log(route.id); // '/a/[b]/[...c]' } \`\`\` ",
                "title": "route",
              },
              {
                "content": "\`params\` is derived from \`url.pathname\` and \`route.id\`. Given a \`route.id\` of \`/a/[b]/[...c]\` and a \`url.pathname\` of \`/a/x/y/z\`, the \`params\` object would look like this: \`\`\`json { 	\\"b\\": \\"x\\", 	\\"c\\": \\"y/z\\" } \`\`\` ",
                "title": "params",
              },
            ],
            "content": "Often the \`load\` function depends on the URL in one way or another. For this, the \`load\` function provides you with \`url\`, \`route\` and \`params\`. ",
            "title": "Using URL data",
          },
          {
            "content": "To get data from an external API or a \`+server.js\` handler, you can use the provided \`fetch\` function, which behaves identically to the [native \`fetch\` web API](https://developer.mozilla.org/en-US/docs/Web/API/fetch) with a few additional features: *   it can be used to make credentialed requests on the server, as it inherits the \`cookie\` and \`authorization\` headers for the page request *   it can make relative requests on the server (ordinarily, \`fetch\` requires a URL with an origin when used in a server context) *   internal requests (e.g. for \`+server.js\` routes) go direct to the handler function when running on the server, without the overhead of an HTTP call *   during server-side rendering, the response will be captured and inlined into the rendered HTML. Note that headers will *not* be serialized, unless explicitly included via [\`filterSerializedResponseHeaders\`](hooks#server-hooks-handle). Then, during hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request - if you got a warning in your browser console when using the browser \`fetch\` instead of the \`load\` \`fetch\`, this is why. \`\`\`js /// file: src/routes/items/[id]/+page.js /** @type {import('./$types').PageLoad} */ export async function load({ fetch, params }) { 	const res = await fetch(\`/api/items/\${params.id}\`); 	const item = await res.json();  	return { item }; } \`\`\` > Cookies will only be passed through if the target host is the same as the SvelteKit application or a more specific subdomain of it. ",
            "title": "Making fetch requests",
          },
          {
            "content": "A server \`load\` function can get and set [\`cookies\`](types#public-types-cookies). \`\`\`js /// file: src/routes/+layout.server.js // @filename: ambient.d.ts declare module '$lib/server/database' { 	export function getUser(sessionid: string | undefined): Promise<{ name: string, avatar: string }> }  // @filename: index.js // ---cut--- import * as db from '$lib/server/database';  /** @type {import('./$types').LayoutServerLoad} */ export async function load({ cookies }) { 	const sessionid = cookies.get('sessionid');  	return { 		user: await db.getUser(sessionid) 	}; } \`\`\` > When setting cookies, be aware of the \`path\` property. By default, the \`path\` of a cookie is the current pathname. If you for example set a cookie at page \`admin/user\`, the cookie will only be available within the \`admin\` pages by default. In most cases you likely want to set \`path\` to \`'/'\` to make the cookie available throughout your app. Both server and universal \`load\` functions have access to a \`setHeaders\` function that, when running on the server, can set headers for the response. (When running in the browser, \`setHeaders\` has no effect.) This is useful if you want the page to be cached, for example: \`\`\`js // @errors: 2322 1360 /// file: src/routes/products/+page.js /** @type {import('./$types').PageLoad} */ export async function load({ fetch, setHeaders }) { 	const url = \`https://cms.example.com/products.json\`; 	const response = await fetch(url);  	// cache the page for the same length of time 	// as the underlying data 	setHeaders({ 		age: response.headers.get('age'), 		'cache-control': response.headers.get('cache-control') 	});  	return response.json(); } \`\`\` Setting the same header multiple times (even in separate \`load\` functions) is an error — you can only set a given header once. You cannot add a \`set-cookie\` header with \`setHeaders\` — use \`cookies.set(name, value, options)\` instead. ",
            "title": "Cookies and headers",
          },
          {
            "content": "Occasionally it's useful for a \`load\` function to access data from a parent \`load\` function, which can be done with \`await parent()\`: \`\`\`js /// file: src/routes/+layout.js /** @type {import('./$types').LayoutLoad} */ export function load() { 	return { a: 1 }; } \`\`\` \`\`\`js /// file: src/routes/abc/+layout.js /** @type {import('./$types').LayoutLoad} */ export async function load({ parent }) { 	const { a } = await parent(); 	return { b: a + 1 }; } \`\`\` \`\`\`js /// file: src/routes/abc/+page.js /** @type {import('./$types').PageLoad} */ export async function load({ parent }) { 	const { a, b } = await parent(); 	return { c: a + b }; } \`\`\` \`\`\`svelte /// file: src/routes/abc/+page.svelte <script> 	/** @type {import('./$types').PageData} */ 	export let data; </script>  <!-- renders \`1 + 2 = 3\` --> <p>{data.a} + {data.b} = {data.c}</p> \`\`\` > Notice that the \`load\` function in \`+page.js\` receives the merged data from both layout \`load\` functions, not just the immediate parent. Inside \`+page.server.js\` and \`+layout.server.js\`, \`parent\` returns data from parent \`+layout.server.js\` files. In \`+page.js\` or \`+layout.js\` it will return data from parent \`+layout.js\` files. However, a missing \`+layout.js\` is treated as a \`({ data }) => data\` function, meaning that it will also return data from parent \`+layout.server.js\` files that are not 'shadowed' by a \`+layout.js\` file Take care not to introduce waterfalls when using \`await parent()\`. Here, for example, \`getData(params)\` does not depend on the result of calling \`parent()\`, so we should call it first to avoid a delayed render. \`\`\`diff /// file: +page.js /** @type {import('./$types').PageLoad} */ export async function load({ params, parent }) { -	const parentData = await parent(); 	const data = await getData(params); +	const parentData = await parent();  	return { 		...data 		meta: { ...parentData.meta, ...data.meta } 	}; } \`\`\` ",
            "title": "Using parent data",
          },
          {
            "content": "If an error is thrown during \`load\`, the nearest [\`+error.svelte\`](routing#error) will be rendered. For *expected* errors, use the \`error\` helper from \`@sveltejs/kit\` to specify the HTTP status code and an optional message: \`\`\`js /// file: src/routes/admin/+layout.server.js // @filename: ambient.d.ts declare namespace App { 	interface Locals { 		user?: { 			name: string; 			isAdmin: boolean; 		} 	} }  // @filename: index.js // ---cut--- import { error } from '@sveltejs/kit';  /** @type {import('./$types').LayoutServerLoad} */ export function load({ locals }) { 	if (!locals.user) { 		throw error(401, 'not logged in'); 	}  	if (!locals.user.isAdmin) { 		throw error(403, 'not an admin'); 	} } \`\`\` If an *unexpected* error is thrown, SvelteKit will invoke [\`handleError\`](hooks#shared-hooks-handleerror) and treat it as a 500 Internal Error. ",
            "title": "Errors",
          },
          {
            "content": "To redirect users, use the \`redirect\` helper from \`@sveltejs/kit\` to specify the location to which they should be redirected alongside a \`3xx\` status code. \`\`\`js /// file: src/routes/user/+layout.server.js // @filename: ambient.d.ts declare namespace App { 	interface Locals { 		user?: { 			name: string; 		} 	} }  // @filename: index.js // ---cut--- import { redirect } from '@sveltejs/kit';  /** @type {import('./$types').LayoutServerLoad} */ export function load({ locals }) { 	if (!locals.user) { 		throw redirect(307, '/login'); 	} } \`\`\` > Make sure you're not catching the thrown redirect, which would prevent SvelteKit from handling it. In the browser, you can also navigate programmatically outside of a \`load\` function using [\`goto\`](modules#$app-navigation-goto) from [\`$app.navigation\`](modules#$app-navigation). ",
            "title": "Redirects",
          },
          {
            "content": "Promises at the *top level* of the returned object will be awaited, making it easy to return multiple promises without creating a waterfall. When using a server \`load\`, *nested* promises will be streamed to the browser as they resolve. This is useful if you have slow, non-essential data, since you can start rendering the page before all the data is available: \`\`\`js /// file: src/routes/+page.server.js /** @type {import('./$types').PageServerLoad} */ export function load() { 	return { 		one: Promise.resolve(1), 		two: Promise.resolve(2), 		streamed: { 			three: new Promise((fulfil) => { 				setTimeout(() => { 					fulfil(3) 				}, 1000); 			}) 		} 	}; } \`\`\` This is useful for creating skeleton loading states, for example: \`\`\`svelte /// file: src/routes/+page.svelte <script> 	/** @type {import('./$types').PageData} */ 	export let data; </script>  <p> 	one: {data.one} </p> <p> 	two: {data.two} </p> <p> 	three: 	{#await data.streamed.three} 		Loading... 	{:then value} 		{value} 	{:catch error} 		{error.message} 	{/await} </p> \`\`\` On platforms that do not support streaming, such as AWS Lambda, responses will be buffered. This means the page will only render once all promises resolve. > Streaming data will only work when JavaScript is enabled. You should avoid returning nested promises from a universal \`load\` function if the page is server rendered, as these are *not* streamed — instead, the promise is recreated when the function re-runs in the browser. ",
            "title": "Streaming with promises",
          },
          {
            "content": "When rendering (or navigating to) a page, SvelteKit runs all \`load\` functions concurrently, avoiding a waterfall of requests. During client-side navigation, the result of calling multiple server \`load\` functions are grouped into a single response. Once all \`load\` functions have returned, the page is rendered. ",
            "title": "Parallel loading",
          },
          {
            "children": [
              {
                "content": "You can also re-run \`load\` functions that apply to the current page using [\`invalidate(url)\`](modules#$app-navigation-invalidate), which re-runs all \`load\` functions that depend on \`url\`, and [\`invalidateAll()\`](modules#$app-navigation-invalidateall), which re-runs every \`load\` function. A \`load\` function depends on \`url\` if it calls \`fetch(url)\` or \`depends(url)\`. Note that \`url\` can be a custom identifier that starts with \`[a-z]:\`: \`\`\`js /// file: src/routes/random-number/+page.js /** @type {import('./$types').PageLoad} */ export async function load({ fetch, depends }) { 	// load reruns when \`invalidate('https://api.example.com/random-number')\` is called... 	const response = await fetch('https://api.example.com/random-number');  	// ...or when \`invalidate('app:random')\` is called 	depends('app:random');  	return { 		number: await response.json() 	}; } \`\`\` \`\`\`svelte /// file: src/routes/random-number/+page.svelte <script> 	import { invalidate, invalidateAll } from '$app/navigation';  	/** @type {import('./$types').PageData} */ 	export let data;  	function rerunLoadFunction() { 		// any of these will cause the \`load\` function to re-run 		invalidate('app:random'); 		invalidate('https://api.example.com/random-number'); 		invalidate(url => url.href.includes('random-number')); 		invalidateAll(); 	} </script>  <p>random number: {data.number}</p> <button on:click={rerunLoadFunction}>Update random number</button> \`\`\` To summarize, a \`load\` function will re-run in the following situations: *   It references a property of \`params\` whose value has changed *   It references a property of \`url\` (such as \`url.pathname\` or \`url.search\`) whose value has changed *   It calls \`await parent()\` and a parent \`load\` function re-ran *   It declared a dependency on a specific URL via [\`fetch\`](#making-fetch-requests) or [\`depends\`](types#public-types-loadevent), and that URL was marked invalid with [\`invalidate(url)\`](modules#$app-navigation-invalidate) *   All active \`load\` functions were forcibly re-run with [\`invalidateAll()\`](modules#$app-navigation-invalidateall) Note that re-running a \`load\` function will update the \`data\` prop inside the corresponding \`+layout.svelte\` or \`+page.svelte\`; it does *not* cause the component to be recreated. As a result, internal state is preserved. If this isn't what you want, you can reset whatever you need to reset inside an [\`afterNavigate\`](modules#$app-navigation-afternavigate) callback, and/or wrap your component in a [\`{#key ...}\`](https://svelte.dev/docs#template-syntax-key) block. ",
                "title": "Manual invalidation",
              },
            ],
            "content": "SvelteKit tracks the dependencies of each \`load\` function to avoid re-running it unnecessarily during navigation. For example, given a pair of \`load\` functions like these... \`\`\`js /// file: src/routes/blog/[slug]/+page.server.js // @filename: ambient.d.ts declare module '$lib/server/database' { 	export function getPost(slug: string): Promise<{ title: string, content: string }> }  // @filename: index.js // ---cut--- import * as db from '$lib/server/database';  /** @type {import('./$types').PageServerLoad} */ export async function load({ params }) { 	return { 		post: await db.getPost(params.slug) 	}; } \`\`\` \`\`\`js /// file: src/routes/blog/[slug]/+layout.server.js // @filename: ambient.d.ts declare module '$lib/server/database' { 	export function getPostSummaries(): Promise<Array<{ title: string, slug: string }>> }  // @filename: index.js // ---cut--- import * as db from '$lib/server/database';  /** @type {import('./$types').LayoutServerLoad} */ export async function load() { 	return { 		posts: await db.getPostSummaries() 	}; } \`\`\` ...the one in \`+page.server.js\` will re-run if we navigate from \`/blog/trying-the-raw-meat-diet\` to \`/blog/i-regret-my-choices\` because \`params.slug\` has changed. The one in \`+layout.server.js\` will not, because the data is still valid. In other words, we won't call \`db.getPostSummaries()\` a second time. A \`load\` function that calls \`await parent()\` will also re-run if a parent \`load\` function is re-run. Dependency tracking does not apply *after* the \`load\` function has returned — for example, accessing \`params.x\` inside a nested [promise](#streaming-with-promises) will not cause the function to re-run when \`params.x\` changes. (Don't worry, you'll get a warning in development if you accidentally do this.) Instead, access the parameter in the main body of your \`load\` function. ",
            "title": "Invalidation",
          },
          {
            "content": "In many server environments, a single instance of your app will serve multiple users. For that reason, per-request or per-user state must not be stored in shared variables outside your \`load\` functions, but should instead be stored in \`event.locals\`. ",
            "title": "Shared state",
          },
        ],
        "content": "Before a [\`+page.svelte\`](routing#page-page-svelte) component (and its containing [\`+layout.svelte\`](routing#layout-layout-svelte) components) can be rendered, we often need to get some data. This is done by defining \`load\` functions. ",
        "title": "Loading data",
      },
    ],
  },
  {
    "filename": "/20-core-concepts/30-form-actions.md",
    "sections": [
      {
        "children": [
          {
            "content": "In the simplest case, a page declares a \`default\` action: \`\`\`js /// file: src/routes/login/+page.server.js /** @type {import('./$types').Actions} */ export const actions = { 	default: async (event) => { 		// TODO log the user in 	} }; \`\`\` To invoke this action from the \`/login\` page, just add a \`<form>\` — no JavaScript needed: \`\`\`svelte /// file: src/routes/login/+page.svelte <form method=\\"POST\\"> 	<label> 		Email 		<input name=\\"email\\" type=\\"email\\"> 	</label> 	<label> 		Password 		<input name=\\"password\\" type=\\"password\\"> 	</label> 	<button>Log in</button> </form> \`\`\` If someone were to click the button, the browser would send the form data via \`POST\` request to the server, running the default action. > Actions always use \`POST\` requests, since \`GET\` requests should never have side-effects. We can also invoke the action from other pages (for example if there's a login widget in the nav in the root layout) by adding the \`action\` attribute, pointing to the page: \`\`\`html /// file: src/routes/+layout.svelte <form method=\\"POST\\" action=\\"/login\\"> 	<!-- content --> </form> \`\`\` ",
            "title": "Default actions",
          },
          {
            "content": "Instead of one \`default\` action, a page can have as many named actions as it needs: \`\`\`diff /// file: src/routes/login/+page.server.js /** @type {import('./$types').Actions} */ export const actions = { -	default: async (event) => { +	login: async (event) => { 		// TODO log the user in 	}, +	register: async (event) => { +		// TODO register the user +	} }; \`\`\` To invoke a named action, add a query parameter with the name prefixed by a \`/\` character: \`\`\`svelte /// file: src/routes/login/+page.svelte <form method=\\"POST\\" action=\\"?/register\\"> \`\`\` \`\`\`svelte /// file: src/routes/+layout.svelte <form method=\\"POST\\" action=\\"/login?/register\\"> \`\`\` As well as the \`action\` attribute, we can use the \`formaction\` attribute on a button to \`POST\` the same form data to a different action than the parent \`<form>\`: \`\`\`diff /// file: src/routes/login/+page.svelte -<form method=\\"POST\\"> +<form method=\\"POST\\" action=\\"?/login\\"> 	<label> 		Email 		<input name=\\"email\\" type=\\"email\\"> 	</label> 	<label> 		Password 		<input name=\\"password\\" type=\\"password\\"> 	</label> 	<button>Log in</button> +	<button formaction=\\"?/register\\">Register</button> </form> \`\`\` > We can't have default actions next to named actions, because if you POST to a named action without a redirect, the query parameter is persisted in the URL, which means the next default POST would go through the named action from before. ",
            "title": "Named actions",
          },
          {
            "children": [
              {
                "content": "If the request couldn't be processed because of invalid data, you can return validation errors — along with the previously submitted form values — back to the user so that they can try again. The \`fail\` function lets you return an HTTP status code (typically 400 or 422, in the case of validation errors) along with the data. The status code is available through \`$page.status\` and the data through \`form\`: \`\`\`diff /// file: src/routes/login/+page.server.js +import { fail } from '@sveltejs/kit';  /** @type {import('./$types').Actions} */ export const actions = { 	login: async ({ cookies, request }) => { 		const data = await request.formData(); 		const email = data.get('email'); 		const password = data.get('password');  +		if (!email) { +			return fail(400, { email, missing: true }); +		}  		const user = await db.getUser(email);  +		if (!user || user.password !== hash(password)) { +			return fail(400, { email, incorrect: true }); +		}  		cookies.set('sessionid', await db.createSession(user));  		return { success: true }; 	}, 	register: async (event) => { 		// TODO register the user 	} }; \`\`\` > Note that as a precaution, we only return the email back to the page — not the password. \`\`\`diff /// file: src/routes/login/+page.svelte <form method=\\"POST\\" action=\\"?/login\\"> +	{#if form?.missing}<p class=\\"error\\">The email field is required</p>{/if} +	{#if form?.incorrect}<p class=\\"error\\">Invalid credentials!</p>{/if} 	<label> 		Email -		<input name=\\"email\\" type=\\"email\\"> +		<input name=\\"email\\" type=\\"email\\" value={form?.email ?? ''}> 	</label> 	<label> 		Password 		<input name=\\"password\\" type=\\"password\\"> 	</label> 	<button>Log in</button> 	<button formaction=\\"?/register\\">Register</button> </form> \`\`\` The returned data must be serializable as JSON. Beyond that, the structure is entirely up to you. For example, if you had multiple forms on the page, you could distinguish which \`<form>\` the returned \`form\` data referred to with an \`id\` property or similar. ",
                "title": "Validation errors",
              },
              {
                "content": "Redirects (and errors) work exactly the same as in [\`load\`](load#redirects): \`\`\`diff /// file: src/routes/login/+page.server.js +import { fail, redirect } from '@sveltejs/kit';  /** @type {import('./$types').Actions} */ export const actions = { +	login: async ({ cookies, request, url }) => { 		const data = await request.formData(); 		const email = data.get('email'); 		const password = data.get('password');  		const user = await db.getUser(email); 		if (!user) { 			return fail(400, { email, missing: true }); 		}  		if (user.password !== hash(password)) { 			return fail(400, { email, incorrect: true }); 		}  		cookies.set('sessionid', await db.createSession(user));  +		if (url.searchParams.has('redirectTo')) { +			throw redirect(303, url.searchParams.get('redirectTo')); +		}  		return { success: true }; 	}, 	register: async (event) => { 		// TODO register the user 	} }; \`\`\` ",
                "title": "Redirects",
              },
            ],
            "content": "Each action receives a \`RequestEvent\` object, allowing you to read the data with \`request.formData()\`. After processing the request (for example, logging the user in by setting a cookie), the action can respond with data that will be available through the \`form\` property on the corresponding page and through \`$page.form\` app-wide until the next update. \`\`\`js // @errors: 2304 /// file: src/routes/login/+page.server.js /** @type {import('./$types').PageServerLoad} */ export async function load({ cookies }) { 	const user = await db.getUserFromSession(cookies.get('sessionid')); 	return { user }; }  /** @type {import('./$types').Actions} */ export const actions = { 	login: async ({ cookies, request }) => { 		const data = await request.formData(); 		const email = data.get('email'); 		const password = data.get('password');  		const user = await db.getUser(email); 		cookies.set('sessionid', await db.createSession(user));  		return { success: true }; 	}, 	register: async (event) => { 		// TODO register the user 	} }; \`\`\` \`\`\`svelte /// file: src/routes/login/+page.svelte <script> 	/** @type {import('./$types').PageData} */ 	export let data;  	/** @type {import('./$types').ActionData} */ 	export let form; </script>  {#if form?.success} 	<!-- this message is ephemeral; it exists because the page was rendered in 	       response to a form submission. it will vanish if the user reloads --> 	<p>Successfully logged in! Welcome back, {data.user.name}</p> {/if} \`\`\` ",
            "title": "Anatomy of an action",
          },
          {
            "content": "After an action runs, the page will be re-rendered (unless a redirect or an unexpected error occurs), with the action's return value available to the page as the \`form\` prop. This means that your page's \`load\` functions will run after the action completes. Note that \`handle\` runs before the action is invoked, and does not re-run before the \`load\` functions. This means that if, for example, you use \`handle\` to populate \`event.locals\` based on a cookie, you must update \`event.locals\` when you set or delete the cookie in an action: \`\`\`js /// file: src/hooks.server.js // @filename: ambient.d.ts declare namespace App { 	interface Locals { 		user: { 			name: string; 		} | null 	} }  // @filename: global.d.ts declare global { 	function getUser(sessionid: string | undefined): { 		name: string; 	}; }  export {};  // @filename: index.js // ---cut--- /** @type {import('@sveltejs/kit').Handle} */ export async function handle({ event, resolve }) { 	event.locals.user = await getUser(event.cookies.get('sessionid')); 	return resolve(event); } \`\`\` \`\`\`js /// file: src/routes/account/+page.server.js // @filename: ambient.d.ts declare namespace App { 	interface Locals { 		user: { 			name: string; 		} | null 	} }  // @filename: index.js // ---cut--- /** @type {import('./$types').PageServerLoad} */ export function load(event) { 	return { 		user: event.locals.user 	}; }  /** @type {import('./$types').Actions} */ export const actions = { 	logout: async (event) => { 		event.cookies.delete('sessionid'); 		event.locals.user = null; 	} }; \`\`\` ",
            "title": "Loading data",
          },
          {
            "children": [
              {
                "content": "The easiest way to progressively enhance a form is to add the \`use:enhance\` action: \`\`\`diff /// file: src/routes/login/+page.svelte <script> +	import { enhance } from '$app/forms';  	/** @type {import('./$types').ActionData} */ 	export let form; </script>  +<form method=\\"POST\\" use:enhance> \`\`\` > Yes, it's a little confusing that the \`enhance\` action and \`<form action>\` are both called 'action'. These docs are action-packed. Sorry. Without an argument, \`use:enhance\` will emulate the browser-native behaviour, just without the full-page reloads. It will: *   update the \`form\` property, \`$page.form\` and \`$page.status\` on a successful or invalid response, but only if the action is on the same page you're submitting from. So for example if your form looks like \`<form action=\\"/somewhere/else\\" ..>\`, \`form\` and \`$page\` will *not* be updated. This is because in the native form submission case you would be redirected to the page the action is on. *   reset the \`<form>\` element and invalidate all data using \`invalidateAll\` on a successful response *   call \`goto\` on a redirect response *   render the nearest \`+error\` boundary if an error occurs *   [reset focus](accessibility#focus-management) to the appropriate element To customise the behaviour, you can provide a \`SubmitFunction\` that runs immediately before the form is submitted, and (optionally) returns a callback that runs with the \`ActionResult\`. Note that if you return a callback, the default behavior mentioned above is not triggered. To get it back, call \`update\`. \`\`\`svelte <form 	method=\\"POST\\" 	use:enhance={({ form, data, action, cancel }) => { 		// \`form\` is the \`<form>\` element 		// \`data\` is its \`FormData\` object 		// \`action\` is the URL to which the form is posted 		// \`cancel()\` will prevent the submission  		return async ({ result, update }) => { 			// \`result\` is an \`ActionResult\` object 			// \`update\` is a function which triggers the logic that would be triggered if this callback wasn't set 		}; 	}} > \`\`\` You can use these functions to show and hide loading UI, and so on. ",
                "title": "use:enhance",
              },
              {
                "content": "If you provide your own callbacks, you may need to reproduce part of the default \`use:enhance\` behaviour, such as showing the nearest \`+error\` boundary. Most of the time, calling \`update\` passed to the callback is enough. If you need more customization you can do so with \`applyAction\`: \`\`\`diff /// file: src/routes/login/+page.svelte <script> +	import { enhance, applyAction } from '$app/forms';  	/** @type {import('./$types').ActionData} */ 	export let form; </script>  <form 	method=\\"POST\\" 	use:enhance={({ form, data, action, cancel }) => { 		// \`form\` is the \`<form>\` element 		// \`data\` is its \`FormData\` object 		// \`action\` is the URL to which the form is posted 		// \`cancel()\` will prevent the submission  		return async ({ result }) => { 			// \`result\` is an \`ActionResult\` object +			if (result.type === 'error') { +				await applyAction(result); +			} 		}; 	}} > \`\`\` The behaviour of \`applyAction(result)\` depends on \`result.type\`: *   \`success\`, \`failure\` — sets \`$page.status\` to \`result.status\` and updates \`form\` and \`$page.form\` to \`result.data\` (regardless of where you are submitting from, in contrast to \`update\` from \`enhance\`) *   \`redirect\` — calls \`goto(result.location)\` *   \`error\` — renders the nearest \`+error\` boundary with \`result.error\` In all cases, [focus will be reset](accessibility#focus-management). ",
                "title": "applyAction",
              },
              {
                "content": "We can also implement progressive enhancement ourselves, without \`use:enhance\`, with a normal event listener on the \`<form>\`: \`\`\`svelte /// file: src/routes/login/+page.svelte <script> 	import { invalidateAll, goto } from '$app/navigation'; 	import { applyAction, deserialize } from '$app/forms';  	/** @type {import('./$types').ActionData} */ 	export let form;  	/** @type {any} */ 	let error;  	async function handleSubmit(event) { 		const data = new FormData(this);  		const response = await fetch(this.action, { 			method: 'POST', 			body: data 		});  		/** @type {import('@sveltejs/kit').ActionResult} */ 		const result = deserialize(await response.text());  		if (result.type === 'success') { 			// re-run all \`load\` functions, following the successful update 			await invalidateAll(); 		}  		applyAction(result); 	} </script>  <form method=\\"POST\\" on:submit|preventDefault={handleSubmit}> 	<!-- content --> </form> \`\`\` Note that you need to \`deserialize\` the response before processing it further using the corresponding method from \`$app/forms\`. \`JSON.parse()\` isn't enough because form actions - like \`load\` functions - also support returning \`Date\` or \`BigInt\` objects. If you have a \`+server.js\` alongside your \`+page.server.js\`, \`fetch\` requests will be routed there by default. To \`POST\` to an action in \`+page.server.js\` instead, use the custom \`x-sveltekit-action\` header: \`\`\`diff const response = await fetch(this.action, { 	method: 'POST', 	body: data, +	headers: { +		'x-sveltekit-action': 'true' +	} }); \`\`\` ",
                "title": "Custom event listener",
              },
            ],
            "content": "In the preceding sections we built a \`/login\` action that [works without client-side JavaScript](https://kryogenix.org/code/browser/everyonehasjs.html) — not a \`fetch\` in sight. That's great, but when JavaScript *is* available we can progressively enhance our form interactions to provide a better user experience. ",
            "title": "Progressive enhancement",
          },
          {
            "content": "Form actions are the preferred way to send data to the server, since they can be progressively enhanced, but you can also use [\`+server.js\`](routing#server) files to expose (for example) a JSON API. ",
            "title": "Alternatives",
          },
          {
            "content": "As we've seen, to invoke a form action you must use \`method=\\"POST\\"\`. Some forms don't need to \`POST\` data to the server — search inputs, for example. For these you can use \`method=\\"GET\\"\` (or, equivalently, no \`method\` at all), and SvelteKit will treat them like \`<a>\` elements, using the client-side router instead of a full page navigation: \`\`\`html <form action=\\"/search\\"> 	<label> 		Search 		<input name=\\"q\\"> 	</label> </form> \`\`\` Submitting this form will navigate to \`/search?q=...\` and invoke your load function but will not invoke an action. As with \`<a>\` elements, you can set the [\`data-sveltekit-reload\`](link-options#data-sveltekit-reload) and [\`data-sveltekit-noscroll\`](link-options#data-sveltekit-noscroll) attributes on the \`<form>\` to control the router's behaviour. ",
            "title": "GET vs POST",
          },
        ],
        "content": "A \`+page.server.js\` file can export *actions*, which allow you to \`POST\` data to the server using the \`<form>\` element. When using \`<form>\`, client-side JavaScript is optional, but you can easily *progressively enhance* your form interactions with JavaScript to provide the best user experience. ",
        "title": "Form actions",
      },
    ],
  },
  {
    "filename": "/20-core-concepts/40-page-options.md",
    "sections": [
      {
        "children": [
          {
            "children": [
              {
                "content": "Unlike the other page options, \`prerender\` also applies to \`+server.js\` files. These files are *not* affected from layouts, but will inherit default values from the pages that fetch data from them, if any. For example if a \`+page.js\` contains this \`load\` function... \`\`\`js /// file: +page.js export const prerender = true;  /** @type {import('./$types').PageLoad} */ export async function load({ fetch }) { 	const res = await fetch('/my-server-route.json'); 	return await res.json(); } \`\`\` ...then \`src/routes/my-server-route.json/+server.js\` will be treated as prerenderable if it doesn't contain its own \`export const prerender = false\`. ",
                "title": "Prerendering server routes",
              },
              {
                "content": "The basic rule is this: for a page to be prerenderable, any two users hitting it directly must get the same content from the server. > Not all pages are suitable for prerendering. Any content that is prerendered will be seen by all users. You can of course fetch personalized data in \`onMount\` in a prerendered page, but this may result in a poorer user experience since it will involve blank initial content or loading indicators. Note that you can still prerender pages that load data based on the page's parameters, such as a \`src/routes/blog/[slug]/+page.svelte\` route. Accessing [\`url.searchParams\`](load#using-url-data-url) during prerendering is forbidden. If you need to use it, ensure you are only doing so in the browser (for example in \`onMount\`). Pages with [actions](form-actions) cannot be prerendered, because a server must be able to handle the action \`POST\` requests. ",
                "title": "When not to prerender",
              },
              {
                "content": "If you set the [ssr option](#ssr) to \`false\`, each request will result in the same empty HTML shell. Since this would result in unnecessary work, SvelteKit defaults to prerendering any pages it finds where \`prerender\` is not explicitly set to \`false\`. ",
                "title": "Prerender and ssr",
              },
              {
                "content": "Because prerendering writes to the filesystem, it isn't possible to have two endpoints that would cause a directory and a file to have the same name. For example, \`src/routes/foo/+server.js\` and \`src/routes/foo/bar/+server.js\` would try to create \`foo\` and \`foo/bar\`, which is impossible. For that reason among others, it's recommended that you always include a file extension — \`src/routes/foo.json/+server.js\` and \`src/routes/foo/bar.json/+server.js\` would result in \`foo.json\` and \`foo/bar.json\` files living harmoniously side-by-side. For *pages*, we skirt around this problem by writing \`foo/index.html\` instead of \`foo\`. Note that this will disable client-side routing for any navigation from this page, regardless of whether the router is already active. ",
                "title": "Route conflicts",
              },
              {
                "content": "If you encounter an error like 'The following routes were marked as prerenderable, but were not prerendered' it's because the route in question (or a parent layout, if it's a page) has \`export const prerender = true\` but the page wasn't actually prerendered, because it wasn't reached by the prerendering crawler. Since these routes cannot be dynamically server-rendered, this will cause errors when people try to access the route in question. There are two ways to fix it: *   Ensure that SvelteKit can find the route by following links from [\`config.kit.prerender.entries\`](configuration#prerender). Add links to dynamic routes (i.e. pages with \`[parameters]\` ) to this option if they are not found through crawling the other entry points, else they are not prerendered because SvelteKit doesn't know what value the parameters should have. Pages not marked as prerenderable will be ignored and their links to other pages will not be crawled, even if some of them would be prerenderable. *   Change \`export const prerender = true\` to \`export const prerender = 'auto'\`. Routes with \`'auto'\` can be dynamically server rendered ",
                "title": "Troubleshooting",
              },
            ],
            "content": "It's likely that at least some routes of your app can be represented as a simple HTML file generated at build time. These routes can be [*prerendered*](glossary#prerendering). \`\`\`js /// file: +page.js/+page.server.js/+server.js export const prerender = true; \`\`\` Alternatively, you can set \`export const prerender = true\` in your root \`+layout.js\` or \`+layout.server.js\` and prerender everything except pages that are explicitly marked as *not* prerenderable: \`\`\`js /// file: +page.js/+page.server.js/+server.js export const prerender = false; \`\`\` Routes with \`prerender = true\` will be excluded from manifests used for dynamic SSR, making your server (or serverless/edge functions) smaller. In some cases you might want to prerender a route but also include it in the manifest (for example, with a route like \`/blog/[slug]\` where you want to prerender your most recent/popular content but server-render the long tail) — for these cases, there's a third option, 'auto': \`\`\`js /// file: +page.js/+page.server.js/+server.js export const prerender = 'auto'; \`\`\` > If your entire app is suitable for prerendering, you can use [\`adapter-static\`](https://github.com/sveltejs/kit/tree/master/packages/adapter-static), which will output files suitable for use with any static webserver. The prerenderer will start at the root of your app and generate files for any prerenderable pages or \`+server.js\` routes it finds. Each page is scanned for \`<a>\` elements that point to other pages that are candidates for prerendering — because of this, you generally don't need to specify which pages should be accessed. If you *do* need to specify which pages should be accessed by the prerenderer, you can do so with the \`entries\` option in the [prerender configuration](configuration#prerender). While prerendering, the value of \`building\` imported from [\`$app/environment\`](modules#$app-environment) will be \`true\`. ",
            "title": "prerender",
          },
          {
            "content": "Normally, SvelteKit renders your page on the server first and sends that HTML to the client where it's [hydrated](glossary#hydration). If you set \`ssr\` to \`false\`, it renders an empty 'shell' page instead. This is useful if your page is unable to be rendered on the server (because you use browser-only globals like \`document\` for example), but in most situations it's not recommended ([see appendix](glossary#ssr)). \`\`\`js /// file: +page.js export const ssr = false; \`\`\` If you add \`export const ssr = false\` to your root \`+layout.js\`, your entire app will only be rendered on the client — which essentially means you turn your app into an SPA. ",
            "title": "ssr",
          },
          {
            "content": "Ordinarily, SvelteKit [hydrates](glossary#hydration) your server-rendered HTML into an interactive client-side-rendered (CSR) page. Some pages don't require JavaScript at all — many blog posts and 'about' pages fall into this category. In these cases you can disable CSR: \`\`\`js /// file: +page.js export const csr = false; \`\`\` > If both \`ssr\` and \`csr\` are \`false\`, nothing will be rendered! ",
            "title": "csr",
          },
          {
            "content": "By default, SvelteKit will remove trailing slashes from URLs — if you visit \`/about/\`, it will respond with a redirect to \`/about\`. You can change this behaviour with the \`trailingSlash\` option, which can be one of \`'never'\` (the default), \`'always'\`, or \`'ignore'\`. As with other page options, you can export this value from a \`+layout.js\` or a \`+layout.server.js\` and it will apply to all child pages. You can also export the configuration from \`+server.js\` files. \`\`\`js /// file: src/routes/+layout.js export const trailingSlash = 'always'; \`\`\` This option also affects [prerendering](#prerender). If \`trailingSlash\` is \`always\`, a route like \`/about\` will result in an \`about/index.html\` file, otherwise it will create \`about.html\`, mirroring static webserver conventions. > Ignoring trailing slashes is not recommended — the semantics of relative paths differ between the two cases (\`./y\` from \`/x\` is \`/y\`, but from \`/x/\` is \`/x/y\`), and \`/x\` and \`/x/\` are treated as separate URLs which is harmful to SEO. ",
            "title": "trailingSlash",
          },
          {
            "content": "With the concept of [adapters](/docs/adapters), SvelteKit is able to run on a variety of platforms. Each of these might have specific configuration to further tweak the deployment — for example on Vercel you could choose to deploy some parts of your app on the edge and others on serverless environments. \`config\` is an object with key-value pairs at the top level. Beyond that, the concrete shape is dependent on the adapter you're using. Every adapter should provide a \`Config\` interface to import for type safety. Consult the documentation of your adapter for more information. \`\`\`js // @filename: ambient.d.ts declare module 'some-adapter' { 	export interface Config { runtime: string } }  // @filename: index.js // ---cut--- /// file: src/routes/+page.js /** @type {import('some-adapter').Config} */ export const config = { 	runtime: 'edge' }; \`\`\` \`config\` objects are merged at the top level (but *not* deeper levels). This means you don't need to repeat all the values in a \`+page.js\` if you want to only override some of the values in the upper \`+layout.js\`. For example this layout configuration... \`\`\`js /// file: src/routes/+layout.js export const config = { 	runtime: 'edge', 	regions: 'all', 	foo: { 		bar: true 	} } \`\`\` ...is overridden by this page configuration... \`\`\`js /// file: src/routes/+page.js export const config = { 	regions: ['us1', 'us2'], 	foo: { 		baz: true 	} } \`\`\` ...which results in the config value \`{ runtime: 'edge', regions: ['us1', 'us2'], foo: { baz: true } }\` for that page. ",
            "title": "config",
          },
        ],
        "content": "By default, SvelteKit will render (or [prerender](glossary#prerendering)) any component first on the server and send it to the client as HTML. It will then render the component again in the browser to make it interactive in a process called [**hydration**](glossary#hydration). For this reason, you need to ensure that components can run in both places. SvelteKit will then initialize a [**router**](routing) that takes over subsequent navigations. You can control each of these on a page-by-page basis by exporting options from [\`+page.js\`](routing#page-page-js) or [\`+page.server.js\`](routing#page-page-server-js), or for groups of pages using a shared [\`+layout.js\`](routing#layout-layout-js) or [\`+layout.server.js\`](routing#layout-layout-server-js). To define an option for the whole app, export it from the root layout. Child layouts and pages override values set in parent layouts, so — for example — you can enable prerendering for your entire app then disable it for pages that need to be dynamically rendered. You can mix and match these options in different areas of your app. For example you could prerender your marketing page for maximum speed, server-render your dynamic pages for SEO and accessibility and turn your admin section into an SPA by rendering it on the client only. This makes SvelteKit very versatile. ",
        "title": "Page options",
      },
    ],
  },
]
`;
